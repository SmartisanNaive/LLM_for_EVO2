"""LLM sequence optimizer - Use large language models to intelligently optimize sequences generated by EVO2"""

from typing import Dict, List, Any, Optional, Tuple
from dataclasses import dataclass
import json
import time
from ..models.glm_client import GLMClient
from ..utils.logger import get_logger


@dataclass
class OptimizationResult:
    """LLM optimization result"""
    original_sequence: str
    optimized_sequence: str
    optimization_score: float
    improvements: List[str]
    reasoning: str
    confidence: float
    timestamp: str
    

class LLMSequenceOptimizer:
    """LLM sequence optimizer
    
    Use large language models to analyze and optimize DNA sequences generated by EVO2,
    providing intelligent sequence improvement suggestions and optimization schemes.
    """
    
    def __init__(self, glm_client: GLMClient):
        self.glm_client = glm_client
        self.logger = get_logger()
        
    def optimize_sequence(self, 
                         sequence: str, 
                         target_specs: Dict[str, Any],
                         optimization_goals: List[str] = None) -> OptimizationResult:
        """Optimize DNA sequence using LLM

    Args:
        sequence: DNA sequence to be optimized
        target_specs: Target specification requirements
        optimization_goals: List of optimization objectives
    
    Returns:
        OptimizationResult: Optimization result
        """
        start_time = time.time()
        
        # Record optimization start
        self.logger.log_llm_optimization_start(sequence, target_specs, optimization_goals)
        
        try:
            # 1. Sequence analysis
            analysis = self._analyze_sequence(sequence, target_specs)
            
            # 2. Generate optimization suggestions
            optimization_suggestions = self._generate_optimization_suggestions(
                sequence, analysis, target_specs, optimization_goals
            )
            
            # 3. Apply optimization
            optimized_sequence = self._apply_optimizations(
                sequence, optimization_suggestions
            )
            
            # 4. Evaluate optimization effect
            optimization_score, improvements, reasoning, confidence = self._evaluate_optimization(
                sequence, optimized_sequence, target_specs
            )
            
            # Create result
            result = OptimizationResult(
                original_sequence=sequence,
                optimized_sequence=optimized_sequence,
                optimization_score=optimization_score,
                improvements=improvements,
                reasoning=reasoning,
                confidence=confidence,
                timestamp=time.strftime('%Y-%m-%d %H:%M:%S')
            )
            
            # Record optimization result
            self.logger.log_llm_optimization_result({
                'original_length': len(sequence),
                'optimized_length': len(optimized_sequence),
                'optimization_score': optimization_score,
                'improvements_count': len(improvements),
                'confidence': confidence,
                'duration': time.time() - start_time
            })
            
            return result
            
        except Exception as e:
            self.logger.log_error(f"LLM sequence optimization failed: {str(e)}")
            # Return original sequence as fallback
            return OptimizationResult(
                original_sequence=sequence,
                optimized_sequence=sequence,
                optimization_score=0.0,
                improvements=[],
                reasoning=f"Optimization failed: {str(e)}",
                confidence=0.0,
                timestamp=time.strftime('%Y-%m-%d %H:%M:%S')
            )
    
    def _analyze_sequence(self, sequence: str, target_specs: Dict[str, Any]) -> Dict[str, Any]:
        """Analyze DNA sequence characteristics"""
        prompt = f"""
You are a professional molecular biologist and bioinformatics expert. Please analyze the characteristics of the following DNA sequence:

Sequence: {sequence}
Target specifications: {json.dumps(target_specs, ensure_ascii=False, indent=2)}

Please analyze from the following perspectives:
1. Sequence length and composition
2. GC content analysis
3. Repeat sequence detection
4. Potential secondary structures
5. Transcription and translation related features
6. Possible problems and risk points

Please return analysis results in JSON format, including specific values and detailed explanations.
        """
        
        try:
            response = self.glm_client.generate_response(prompt)
            # Try to parse JSON response
            if response.startswith('```json'):
                response = response.split('```json')[1].split('```')[0]
            elif response.startswith('```'):
                response = response.split('```')[1].split('```')[0]
            
            return json.loads(response)
        except Exception as e:
            self.logger.log_error(f"Sequence analysis failed: {str(e)}")
            return {
                "length": len(sequence),
                "gc_content": sequence.count('G') + sequence.count('C'),
                "analysis_error": str(e)
            }
    
    def _generate_optimization_suggestions(self, 
                                         sequence: str, 
                                         analysis: Dict[str, Any],
                                         target_specs: Dict[str, Any],
                                         optimization_goals: List[str]) -> List[Dict[str, Any]]:
        """Generate optimization suggestions"""
        goals_text = "\n".join([f"- {goal}" for goal in (optimization_goals or [
            "Improve expression efficiency",
            "Optimize codon usage",
            "Reduce secondary structure",
            "Improve stability"
        ])])
        
        prompt = f"""
Based on the following sequence analysis results, please provide specific optimization suggestions:

Original sequence: {sequence}
Analysis results: {json.dumps(analysis, ensure_ascii=False, indent=2)}
Target specifications: {json.dumps(target_specs, ensure_ascii=False, indent=2)}

Optimization goals:
{goals_text}

Please provide specific optimization suggestions, including:
1. Positions that need modification
2. Reasons for modification
3. Suggested replacement sequences
4. Expected improvement effects

Please return in JSON array format, each suggestion contains position, original, replacement, reason, expected_improvement fields.
        """
        
        try:
            response = self.glm_client.generate_response(prompt)
            if response.startswith('```json'):
                response = response.split('```json')[1].split('```')[0]
            elif response.startswith('```'):
                response = response.split('```')[1].split('```')[0]
            
            return json.loads(response)
        except Exception as e:
            self.logger.log_error(f"Generate optimization suggestions failed: {str(e)}")
            return []
    
    def _apply_optimizations(self, 
                           sequence: str, 
                           suggestions: List[Dict[str, Any]]) -> str:
        """Apply optimization suggestions"""
        optimized_sequence = sequence
        
        # Sort by position in reverse order to avoid position offset issues
        sorted_suggestions = sorted(suggestions, 
                                  key=lambda x: x.get('position', 0), 
                                  reverse=True)
        
        for suggestion in sorted_suggestions:
            try:
                position = suggestion.get('position', 0)
                original = suggestion.get('original', '')
                replacement = suggestion.get('replacement', '')
                
                if (position >= 0 and 
                    position + len(original) <= len(optimized_sequence) and
                    optimized_sequence[position:position+len(original)] == original):
                    
                    optimized_sequence = (
                        optimized_sequence[:position] + 
                        replacement + 
                        optimized_sequence[position+len(original):]
                    )
                    
            except Exception as e:
                self.logger.log_error(f"Apply optimization suggestions failed: {str(e)}")
                continue
        
        return optimized_sequence
    
    def _evaluate_optimization(self, 
                             original: str, 
                             optimized: str, 
                             target_specs: Dict[str, Any]) -> Tuple[float, List[str], str, float]:
        """Evaluate optimization effect"""
        prompt = f"""
Please evaluate the effect of the following DNA sequence optimization:

Original sequence: {original}
Optimized sequence: {optimized}
Target specifications: {json.dumps(target_specs, ensure_ascii=False, indent=2)}

Please evaluate from the following perspectives:
1. Overall improvement degree (0-100 points)
2. List of specific improvement points
3. Optimization reasoning process
4. Result confidence (0-1)

Please return evaluation results in JSON format, containing score, improvements, reasoning, confidence fields.
        """
        
        try:
            response = self.glm_client.generate_response(prompt)
            if response.startswith('```json'):
                response = response.split('```json')[1].split('```')[0]
            elif response.startswith('```'):
                response = response.split('```')[1].split('```')[0]
            
            result = json.loads(response)
            return (
                result.get('score', 0.0),
                result.get('improvements', []),
                result.get('reasoning', ''),
                result.get('confidence', 0.0)
            )
        except Exception as e:
            self.logger.log_error(f"Evaluate optimization effect failed: {str(e)}")
            return 0.0, [], f"Evaluation failed: {str(e)}", 0.0
    
    def batch_optimize_sequences(self, 
                               sequences: List[str], 
                               target_specs: Dict[str, Any],
                               optimization_goals: List[str] = None) -> List[OptimizationResult]:
        """Batch optimize sequences"""
        results = []
        
        for i, sequence in enumerate(sequences):
            print(f"🔧 Optimizing sequence {i+1}/{len(sequences)}...")
            result = self.optimize_sequence(sequence, target_specs, optimization_goals)
            results.append(result)
            
        return results
    
    def get_optimization_summary(self, results: List[OptimizationResult]) -> Dict[str, Any]:
        """Get optimization summary"""
        if not results:
            return {}
        
        total_sequences = len(results)
        improved_sequences = len([r for r in results if r.optimization_score > 0])
        avg_score = sum(r.optimization_score for r in results) / total_sequences
        avg_confidence = sum(r.confidence for r in results) / total_sequences
        
        all_improvements = []
        for result in results:
            all_improvements.extend(result.improvements)
        
        return {
            "total_sequences": total_sequences,
            "improved_sequences": improved_sequences,
            "improvement_rate": improved_sequences / total_sequences,
            "average_score": avg_score,
            "average_confidence": avg_confidence,
            "common_improvements": list(set(all_improvements)),
            "best_result": max(results, key=lambda r: r.optimization_score)
        }